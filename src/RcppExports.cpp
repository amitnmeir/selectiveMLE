// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppArmadillo.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// lassoSampler
/**  * Main workhorse implementing the selective MLE sampler for the  * lasso.  The function alternates between sampling the active set  * coefficients and performing stochastic gradient updates.  It is  * exposed to R via Rcpp and is not intended to be called directly  * by users.  *  * @param initEst  Initial estimate of the regression coefficients.  * @param initSamp Starting point for the sampler.  * @param oneCov   Conditional covariance matrix for the active set.  * @param XmX      Cross product of the design matrix.  * @param XmXinv   Inverse of XmX restricted to the active set.  * @param condSigma Conditional variances for each coefficient.  * @param lambda   Lasso penalty value.  * @param ysigsq   Residual variance.  * @param zeroMean Mean vector for the zero part of Ay.  * @param sqrtZero Square root of the covariance for the zero part.  * @param u0mat    Constraint matrix defining the selection event.  * @param n,p      Dimensions of the design matrix.  * @param nsamp    Number of Gibbs samples per outer iteration.  * @param burnin   Length of the burn-in period.  * @param Xy       Cross product of X and y.  * @param estimateMat Matrix to store estimates at each iteration.  * @param sampMat  Matrix to store sampler draws at each iteration.  * @param delay,stepRate,stepCoef Parameters controlling the optimiser.  * @param gradientBound Bound on the gradient magnitude.  * @param assumeConvergence Iteration at which optimisation stops.  * @param naive    Naive lasso estimate used for bounding.  * @param methodExact Whether to perform exact polyhedral sampling.  * @param verbose  If true, progress is printed to the console.  */ NumericVector lassoSampler(const NumericVector initEst, const NumericVector initSamp, NumericMatrix oneCov, NumericMatrix XmX, NumericMatrix XmXinv, NumericVector condSigma, double lambda, double ysigsq, NumericVector zeroMean, NumericMatrix sqrtZero, NumericMatrix u0mat, int n, int p, int nsamp, int burnin, NumericVector Xy, NumericMatrix& estimateMat, NumericMatrix& sampMat, int delay, double stepRate, double stepCoef, double gradientBound, int assumeConvergence, NumericVector naive, bool methodExact, bool verbose);
RcppExport SEXP _selectiveMLE_lassoSampler(SEXP initEstSEXP, SEXP initSampSEXP, SEXP oneCovSEXP, SEXP XmXSEXP, SEXP XmXinvSEXP, SEXP condSigmaSEXP, SEXP lambdaSEXP, SEXP ysigsqSEXP, SEXP zeroMeanSEXP, SEXP sqrtZeroSEXP, SEXP u0matSEXP, SEXP nSEXP, SEXP pSEXP, SEXP nsampSEXP, SEXP burninSEXP, SEXP XySEXP, SEXP estimateMatSEXP, SEXP sampMatSEXP, SEXP delaySEXP, SEXP stepRateSEXP, SEXP stepCoefSEXP, SEXP gradientBoundSEXP, SEXP assumeConvergenceSEXP, SEXP naiveSEXP, SEXP methodExactSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type initEst(initEstSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type initSamp(initSampSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type oneCov(oneCovSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type XmX(XmXSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type XmXinv(XmXinvSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type condSigma(condSigmaSEXP);
    Rcpp::traits::input_parameter< double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< double >::type ysigsq(ysigsqSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type zeroMean(zeroMeanSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type sqrtZero(sqrtZeroSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type u0mat(u0matSEXP);
    Rcpp::traits::input_parameter< int >::type n(nSEXP);
    Rcpp::traits::input_parameter< int >::type p(pSEXP);
    Rcpp::traits::input_parameter< int >::type nsamp(nsampSEXP);
    Rcpp::traits::input_parameter< int >::type burnin(burninSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type Xy(XySEXP);
    Rcpp::traits::input_parameter< NumericMatrix& >::type estimateMat(estimateMatSEXP);
    Rcpp::traits::input_parameter< NumericMatrix& >::type sampMat(sampMatSEXP);
    Rcpp::traits::input_parameter< int >::type delay(delaySEXP);
    Rcpp::traits::input_parameter< double >::type stepRate(stepRateSEXP);
    Rcpp::traits::input_parameter< double >::type stepCoef(stepCoefSEXP);
    Rcpp::traits::input_parameter< double >::type gradientBound(gradientBoundSEXP);
    Rcpp::traits::input_parameter< int >::type assumeConvergence(assumeConvergenceSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type naive(naiveSEXP);
    Rcpp::traits::input_parameter< bool >::type methodExact(methodExactSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(lassoSampler(initEst, initSamp, oneCov, XmX, XmXinv, condSigma, lambda, ysigsq, zeroMean, sqrtZero, u0mat, n, p, nsamp, burnin, Xy, estimateMat, sampMat, delay, stepRate, stepCoef, gradientBound, assumeConvergence, naive, methodExact, verbose));
    return rcpp_result_gen;
END_RCPP
}
// mvtSampler
/**  * Gibbs sampler for a multivariate normal vector subject to  * coordinate-wise truncation.  The `selected` argument indicates which  * coordinates are truncated on one side only and which are bounded on  * both sides.  Samples are returned after an initial burn-in period and  * optional thinning.  */ NumericVector mvtSampler(NumericVector y, NumericVector mu, IntegerVector selected, NumericMatrix threshold, NumericMatrix precision, int nsamp, int burnin, int trim, bool verbose);
RcppExport SEXP _selectiveMLE_mvtSampler(SEXP ySEXP, SEXP muSEXP, SEXP selectedSEXP, SEXP thresholdSEXP, SEXP precisionSEXP, SEXP nsampSEXP, SEXP burninSEXP, SEXP trimSEXP, SEXP verboseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type y(ySEXP);
    Rcpp::traits::input_parameter< NumericVector >::type mu(muSEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type selected(selectedSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type threshold(thresholdSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type precision(precisionSEXP);
    Rcpp::traits::input_parameter< int >::type nsamp(nsampSEXP);
    Rcpp::traits::input_parameter< int >::type burnin(burninSEXP);
    Rcpp::traits::input_parameter< int >::type trim(trimSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    rcpp_result_gen = Rcpp::wrap(mvtSampler(y, mu, selected, threshold, precision, nsamp, burnin, trim, verbose));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_selectiveMLE_lassoSampler", (DL_FUNC) &_selectiveMLE_lassoSampler, 26},
    {"_selectiveMLE_mvtSampler", (DL_FUNC) &_selectiveMLE_mvtSampler, 9},
    {NULL, NULL, 0}
};

RcppExport void R_init_selectiveMLE(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
