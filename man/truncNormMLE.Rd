% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/normMLE.R
\name{truncNormMLE}
\alias{truncNormMLE}
\title{Maximum Likelihood Inference for Selected Normal Means}
\usage{
truncNormMLE(y, sigma, threshold, cialpha = 0.05, maxiter = 1000,
  stepRate = 0.7, stepCoef = 1, verbose = TRUE)
}
\arguments{
\item{y}{the observed normal vector.}

\item{sigma}{the covariance matrix of \code{y}.}

\item{threshold}{a scalar, vector of size \code{length(y)} or matrix of
dimensions \code{length(y) X 2}. See description for more details.}

\item{cialpha}{the confidence intervals will be constructed at a
confidence level \code{1 - cialpha}.}

\item{maxiter}{the number of stochastic gradient steps to take.}

\item{stepRate}{number of optimization steps to take before decreasing
the gradient step size.}

\item{stepCoef}{fixed step size for stochastic gradient.}

\item{verbose}{whether to report the progess of the optimization routine as
it runs.}

\item{optimSteps}{number of stochastic gradient steps to take.}

\item{sampSteps}{the rate at which to decrease the step size of the
stochastic gradient.}
}
\value{
\code{truncNormMLE} returns an object of class \code{truncNormMLE} which
  contains the following variables:

  * \code{mle} the conditional MLE.

  * \code{CI} the selection adjusted confidence intervals.

  * \code{solutionPath} the solution path of the stochastic gradient
  method.

  * \code{sampleMat} samples from the estimated truncated normal distribution.
  These samples are used to compute the post-selection confidence intervals.
}
\description{
\code{truncNormMLE} computes the conditional MLE for subsets of
mean vectors of multivariate normal distributions. Conditional estimates are
computed via a stochastic gradient/contrastive divergence method and post-selection
confidence intervals are computed based on the theoretical apporximate distribution
of the conditional MLE.
}
\details{
The routine computes the conditional MLE for selected normal means.
The (coordinate wise) selection rule is assumed to be
\code{y[i] > threshold[2, i]  | y[i] < threshold[1, i]}. The function expects
the threshold input to be either a scalar, in which case it will be converted into
a matrix with values \code{c(-abs(threshold), abs(threshold)} at each row, a vector
of size \code{length(y)}, in which case it will be converted to matrix via the formula
\code{cbind(-abs(threshold), abs(threshold))}, or a matrix of dimension
\code{length(y) X 2}.

The default optimization parameter values \code{stepRate} and \code{stepCoef} are
quite well optimized
and should work well for most problems, as \code{y} is standardized before
the optimization starts.
}
